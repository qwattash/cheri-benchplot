import re
import subprocess
from dataclasses import dataclass
from pathlib import Path

import cxxfilt
import networkx as nx

from ..core.artefact import (BenchmarkIterationTarget, PLDataFrameLoadTask, Target)
from ..core.config import Config, ConfigPath
from ..core.task import DataGenTask, output


@dataclass
class IngestPMCStatStacksConfig(Config):
    """
    Configuration for the task that loads pmcstat stacks files.
    """
    #: Path of the stacks files to ingest
    path: ConfigPath
    #: Stacks file pattern
    #: Use benchmark parameter templates to substitute the name for each
    #: different benchmark variation here. Note that a special {iteration}
    #: template key is used to substitute the iteration number.
    stack_file_pattern: str = "pmcstat.{iteration}.stacks"


class IngestPMCStatStacks(DataGenTask):
    """
    Task that takes data from stack sample files generated by

    pmcstat -R <logfile> -G <stacksfile>

    and produces a tree weighted by the relative frequency of the children.
    """
    task_config_class = IngestPMCStatStacksConfig
    task_namespace = "pmc"
    task_name = "ingest-stacks"
    public = True

    @output
    def data(self):
        return BenchmarkIterationTarget(self, "stacks", ext="graphml")

    @output
    def collapsed_stacks(self):
        return BenchmarkIterationTarget(self, "collapsed-stacks", ext="txt")

    def run(self):
        stackcollapse = self.session.user_config.flamegraph_path / "stackcollapse-pmc.pl"
        if stackcollapse.exists():
            self.logger.debug("Folding stacks using %s", stackcollapse)

        data_paths = list(self.data.iter_paths())
        stc_paths = list(self.collapsed_stacks.iter_paths())
        for i in range(self.benchmark.config.iterations):
            stack_file = self.config.stack_file_pattern.format(iteration=i + 1)
            data_file = self.config.path / stack_file
            self.logger.debug("Ingest %s", data_file)

            if not data_file.exists():
                self.logger.error("Data file missing %s", data_file)
                continue
            stacks = self._parse_stacks(data_file)
            self.logger.debug("Parsed stacks: %d nodes", len(stacks.nodes))
            nx.write_graphml(stacks, data_paths[i])

            if stackcollapse.exists():
                with open(stc_paths[i], "w+") as outfd:
                    subprocess.run([stackcollapse, data_file], stdout=outfd)

    def _parse_line(self, line: str) -> dict:
        """
        Parse a line in the stacks file.

        This will have the format:
        <spaces><percent> [<N_samples>] <symbol> @ <location>

        We extract these fields into a dictionary and return it.
        The leading number of spaces is parsed as the 'level'.
        """
        expr = (r"^(?P<spaces>\s*)(?P<percent>[0-9.]+)%\s+\[(?P<samples>[0-9]+)\]"
                r"\s+(?P<raw_symbol>[0-9a-zA-Z_]+)\s*(?:@\s+(?P<path>[0-9a-zA-Z_/.-]+))?")

        m = re.match(expr, line)
        if not m:
            self.logger.error("Failed to parse: invalid stacks line '%s'", line)
            raise RuntimeError("Invalid stacks file")
        groups = m.groupdict()
        # Fixup data types and level value
        groups["samples"] = int(groups["samples"])
        groups["percent"] = float(groups["percent"])
        groups["level"] = len(groups.pop("spaces"))
        raw_symbol = groups.pop("raw_symbol")
        try:
            symbol = cxxfilt.demangle(raw_symbol)
        except cxxfilt.InvalidName:
            symbol = raw_symbol
        groups["symbol"] = symbol

        return groups

    def _parse_stacks(self, stacks_file: Path) -> nx.DiGraph:
        node = 0
        stacks = nx.DiGraph()

        # Create the root node
        stacks.add_node(0)
        parents = [0]

        with open(stacks_file, "r") as fd:
            # The first line should be
            # @ <counter_name> [<N> samples]
            header = fd.readline()
            m = re.match(r"@\s+(?P<counter>[A-Za-z0-9_-]+)\s+\[(?P<samples>[0-9]+) samples\]", header)
            if not m:
                self.logger.error("Failed to parse %s: invalid header line %s", stacks_file, header)
                raise RuntimeError("Invalid stacks file")
            groups = m.groupdict()
            stacks.graph["samples"] = groups["samples"]
            stacks.graph["counter"] = groups["counter"]

            for line in fd:
                line = line.rstrip()
                if not line:
                    # Skip blank lines
                    continue
                node += 1

                entry = self._parse_line(line)
                # check if going back to a previous level
                while entry["level"] < len(parents) - 1:
                    parents.pop()
                parent = parents[-1]
                stacks.add_node(node)
                stacks.nodes[node]["samples"] = entry["samples"]
                stacks.nodes[node]["symbol"] = entry["symbol"]
                if entry["path"]:
                    stacks.nodes[node]["path"] = entry["path"]
                edge = (parent, node)
                stacks.add_edge(*edge)
                stacks.edges[edge]["weight"] = float(entry["percent"]) / 100
                parents.append(node)

        return stacks


@dataclass
class IngestPMCStatCountersConfig(Config):
    """
    Configuration for the task that loads pmcstat counters output.
    """
    #: Path of the counter data files to ingest
    path: ConfigPath
    #: Counter file pattern
    #: Use benchmark parameter templates to substitute the name for each
    #: different benchmark variation here. Note that a special {iteration}
    #: template key is used to substitute the iteration number.
    counter_file_pattern: str = "pmcstat.{iteration}.cnt"


class IngestPMCStatStacks(DataGenTask):
    """
    Task that takes data from pmcstat counters data files generated by

    pmcstat -O <logfile> -P counter ...

    and produces a dataframe containing the samples.

    Note that we assume that sample counters are incremental
    """
    task_config_class = IngestPMCStatCountersConfig
    task_namespace = "pmc"
    task_name = "ingest-counters"
    public = True

    @output
    def counter_data(self):
        return Target(self, "counter-data", loader=PLDataFrameLoadTask)

    def run(self):
        pass
