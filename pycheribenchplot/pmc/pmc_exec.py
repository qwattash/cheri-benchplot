import re
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import List, Optional

import pandas as pd
import polars as pl

from ..core.artefact import PLDataFrameLoadTask, RemoteBenchmarkIterationTarget
from ..core.config import Config, config_field
from ..core.task import ExecutionTask, output


class PMCSet(Enum):
    """
    Pre-defined sets of counters
    """
    Instr = "instr"
    CheriInstr = "cheri-instr"
    L1Cache = "l1cache"
    L2Cache = "l2cache"
    L3Cache = "l3cache"
    Branch = "branch"
    TLB = "tlb"
    Stall = "stall"
    Revocation = "revocation"


PMC_SET_COUNTERS = {
    PMCSet.Instr: [
        "CPU_CYCLES", "INST_RETIRED", "INST_SPEC", "LD_SPEC", "ST_SPEC", "EXC_SVC", "EXC_IRQ", "EXC_TRAP_IRQ",
        "STALL_FRONTEND", "STALL_BACKEND"
    ],
    PMCSet.CheriInstr: [
        "CPU_CYCLES", "INST_RETIRED", "INST_SPEC", "EXECUTIVE_ENTRY", "EXECUTIVE_EXIT", "INST_SPEC_RESTRICTED",
        "CAP_LD_SPEC", "CAP_ST_SPEC", "BR_MIS_PRED", "BR_MIS_PRED_RS"
    ],
    PMCSet.L1Cache: [
        "CPU_CYCLES", "INST_RETIRED", "L1D_CACHE_REFILL", "L1D_CACHE", "L1D_CACHE_WB_VICTIM", "L1I_CACHE",
        "L1I_CACHE_REFILL", "L1D_CACHE_RD", "L1D_CACHE_WR"
    ],
    PMCSet.L2Cache: [
        "CPU_CYCLES", "INST_RETIRED", "L2D_CACHE_REFILL", "L2D_CACHE", "L2D_CACHE_WB_VICTIM", "L2D_CACHE_INVAL",
        "L2D_CACHE_RD", "L2D_CACHE_WR", "BUS_ACCESS"
    ],
    PMCSet.L3Cache: [
        "CPU_CYCLES", "INST_RETIRED", "L3D_CACHE", "L3D_CACHE_REFILL", "L3_CACHE_RD", "BUS_ACCESS_RD", "BUS_ACCESS_WR",
        "MEM_ACCESS_RD", "MEM_ACCESS_WR"
    ],
    PMCSet.Branch: [
        "CPU_CYCLES", "INST_RETIRED", "BR_MIS_PRED", "BR_PRED", "BR_MIS_PRED_RS", "BR_RETIRED", "BR_MIS_PRED_RETIRED",
        "BR_RETURN_SPEC"
    ],
    PMCSet.TLB: [
        "CPU_CYCLES", "INST_RETIRED", "L1I_TLB_REFILL", "L1D_TLB_REFILL", "L1I_TLB", "L1D_TLB", "L2D_TLB_REFILL",
        "L2D_TLB", "ITLB_WALK", "DTLB_WALK"
    ],
    PMCSet.Stall: [
        "CPU_CYCLES", "INST_RETIRED", "STALL", "STALL_FRONTEND", "STALL_BACKEND", "STALL_SLOT", "STALL_SLOT_FRONTEND",
        "STALL_SLOT_BACKEND", "STALL_BACKEND_MEM"
    ],
    PMCSet.Revocation: [
        "CPU_CYCLES", "INST_RETIRED", "INST_SPEC", "L1D_CACHE_REFILL", "L1D_CACHE", "BUS_ACCESS", "L1D_TLB_REFILL",
        "L1D_TLB", "L2D_TLB_REFILL", "DTLB_WALK"
    ]
}


@dataclass
class PMCExecConfig(Config):
    """
    HWPMC configuration.
    """
    system_mode: bool = config_field(False, desc="Use system mode counters")
    sampling_mode: bool = config_field(False, desc="Use sampling vs counting mode")
    sampling_rate: int = config_field(97553, desc="Counter sampling rate, only relevant in sampling mode")
    counters: List[str] = config_field(list, desc="List of PMC counters to use")
    group: Optional[str] = config_field(None, desc="Pre-defined group of counters, overrides 'counters' option")
    follow_fork: bool = config_field(False, desc="Trace children on fork")

    @property
    def counters_list(self):
        if self.group:
            try:
                pmc_set = PMCSet(self.group)
            except ValueError:
                raise RuntimeError("Invalid configuration")
            return PMC_SET_COUNTERS[pmc_set]
        else:
            return self.counters


class IngestPMCCounters(PLDataFrameLoadTask):
    """
    Internal task that loads pmc counters for a benchmark run.

    When counting mode is used, this task expects data from pmcstat counters files
    generated by `pmcstat -O <logfile> -P counter` and produces a dataframe
    containing the samples. Note that we assume that sample counters are incremental.
    """
    task_namespace = "pmc"
    task_name = "cnt-ingest"

    def __init__(self, target):
        super().__init__(target)
        config: PMCExecConfig = target.task.config
        if config.sampling_mode:
            self.logger.error("Can't import sampling_mode counters")
            raise RuntimeError("Invalid configuration")
        self.counter_group = config.group or "/".join(config.counters)
        self.counter_names = [c.lower() for c in config.counters_list]
        self.system_mode = config.system_mode

    def _load_one(self, path: Path) -> pl.DataFrame:
        self.logger.debug("Ingest %s", path)
        with open(path, "r") as pmc_fd:
            # The first line should be
            # # p/COUNTER ..
            header = pmc_fd.readline()
            if not header.startswith("#"):
                self.logger.error("Invalid PMC file header")
                raise RuntimeError("PMC file parsing error")
            matches = re.findall(r"[ps]/(?P<col>[a-zA-Z0-9_/-]+)", header)
            cols = [c.lower() for c in matches]
        df = pl.from_pandas(pd.read_csv(path, sep=r"\s+", header=0, names=cols, index_col=False))
        # Assume we have all numeric columns and the counters are incremental
        df = df.sum()
        # Default counter group to identify multiple pmcstat configurations
        df = df.with_columns(pl.lit(self.counter_group).alias("_counter_group"))
        # If these are system-mode counters we have to distinguish between CPUs
        if self.system_mode:
            # The columns are in the format <N>/<counter> where <N> is the CPU index
            tmp_df = df.unpivot(index=["_counter_group"], variable_name="_counter", value_name="_value")
            tmp_df = tmp_df.with_columns(
                pl.col("_counter").str.split(by="/").list.first().cast(pl.Int32).alias("_cpu"),
                pl.col("_counter").str.split(by="/").list.last().alias("_counter"))
            df = tmp_df.pivot(on="_counter", index=["_counter_group", "_cpu"], values="_value")
        return df


class PMCExec(ExecutionTask):
    """
    Configure hwpmc run for the current benchmark.

    If the benchmark does not support hwpmc, the script context will be ignored
    and the data ingest phase will fail.
    """
    task_namespace = "pmc"
    task_name = "exec"
    task_config_class = PMCExecConfig
    public = True

    @output
    def pmc_data(self):
        return RemoteBenchmarkIterationTarget(self, "hwpmc", ext="out")

    def get_counters_loader(self):
        return IngestPMCCounters(self.pmc_data)

    def run(self):
        self.script.extend_context({
            "hwpmc_config": self.config,
            "hwpmc_counters": self.config.counters_list,
            "hwpmc_gen_output": self.pmc_data.shell_path_builder()
        })
